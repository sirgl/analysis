package sirgl.syntax

interface SyntaxDescription {
    val nodes: List<SyntaxNode>
}



/**
 * @param name lowercased
 */
sealed class SyntaxNode(val name: String)

sealed class LeafNode(name: String) : SyntaxNode(name)

open class TextLeaf(val text: String, name: String) : LeafNode(name)

class KeywordLeaf(text: String, name: String) : TextLeaf(text, name + "_kw")

class RuleLeafNode(name: String) : LeafNode(name)

class BranchNode(name: String) : SyntaxNode(name)

val startIndex = 5

fun generate(nodes: List<SyntaxNode>, startIndex: Int) : String {
    var currentIndex = startIndex
    return buildString {
        append("// This file is autogenerated, not supposed for manual editing.\n\n")
        append("use syntax_base::syntax_kind::SyntaxKindId;\n")
        append("use syntax_base::syntax::SyntaxInfo;\n\n")
        generateNodes(nodes, currentIndex)
        generateInfo(nodes)
    }
}

private fun StringBuilder.generateNodes(nodes: List<SyntaxNode>, currentIndex: Int) {
    var currentIndex1 = currentIndex
    for (node in nodes) {
        append("pub const ${node.name.toUpperCase()}: SyntaxKindId = SyntaxKindId::new($currentIndex1);\n")
        currentIndex1++
    }
    append("\n")
}

private fun StringBuilder.generateInfo(nodes: List<SyntaxNode>) {
    append("""
fn infos(id: SyntaxKindId) -> &'static SyntaxInfo  {
    match id {
${
            buildString {
                    for (node in nodes) {
                        append("        ${node.name.toUpperCase()} => &SyntaxInfo { name: \"${node.name.toUpperCase()}\" },\n")
                    }
                }
        }       }
    }
    """.trimIndent())
}
